<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [openrecord-dev] Re: Rhizome and OpenRecord
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/openrecord-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:openrecord-dev%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-dev%5D%20Re%3A%20Rhizome%20and%20OpenRecord&In-Reply-To=%3C443AD92C.2030703%40dojotoolkit.org%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000298.html">
   <LINK REL="Next"  HREF="000300.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[openrecord-dev] Re: Rhizome and OpenRecord</H1>
    <B>Brian Douglas Skinner</B> 
    <A HREF="mailto:openrecord-dev%40lists.berlios.de?Subject=Re%3A%20%5Bopenrecord-dev%5D%20Re%3A%20Rhizome%20and%20OpenRecord&In-Reply-To=%3C443AD92C.2030703%40dojotoolkit.org%3E"
       TITLE="[openrecord-dev] Re: Rhizome and OpenRecord">skinner at dojotoolkit.org
       </A><BR>
    <I>Tue Apr 11 00:16:03 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000298.html">[openrecord-dev] Re: Rhizome and OpenRecord
</A></li>
        <LI>Next message: <A HREF="000300.html">[openrecord-dev] Dojo Developer Day -- Sat May 13, 2006 -- Mountain View CA
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#299">[ date ]</a>
              <a href="thread.html#299">[ thread ]</a>
              <a href="subject.html#299">[ subject ]</a>
              <a href="author.html#299">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;<i>So the idea is that each element in a list has an ordinal number 
</I>&gt;&gt;<i>-- ordered lists themselves are never explicitly represented -- 
</I>&gt;&gt;<i>you can take any query result set (a set of items/resources or  
</I>&gt;&gt;<i>a set of entries/statements) and view the results as an ordered 
</I>&gt;&gt;<i>list by sorting the results based on their ordinal numbers.
</I>&gt;<i> 
</I>&gt;<i> ok, i think i get it now. It's a little unusual in that this
</I>&gt;<i> establishes a total order over every item and entry -- looking 
</I>&gt;<i> at the source code, it seems that if an ordinal has not been 
</I>&gt;<i> explicity set, you use the record's timestamp as the ordinal.
</I>
Yup, that's right.

&gt;<i> Besides saving the order of columns in a table, are explicitly 
</I>&gt;<i> ordered relationships used elsewhere in OpenRecord?  
</I>
Yes, I think ordinal-based orderings show up in lots of places in the UI:
   - the order of menu items in the nav-bar
   - the order of lozenges within a single table cell
   - the order of columns in a table
   - the order of rows in a table (if it hasn't been sorted)
   - the order of sections on a page

&gt;<i> The closest notion RDF has to this is an infinite set of 
</I>&gt;<i> properties named rdf:_1 through rdf:_n that are uses to 
</I>&gt;<i> establish ordered relations, but not any sort of global order.  
</I>&gt;<i> 
</I>&gt;<i> So... to deal with this: when converting an entry to RDF, if 
</I>&gt;<i> an entry has an explicit ordinal associated with, instead of 
</I>&gt;<i> adding a single statement, add two statements:
</I>&gt;<i> 
</I>&gt;<i> item attribute rdf:Seq
</I>&gt;<i> and
</I>&gt;<i> rdf:Seq rdf:_&lt;ordinal&gt; value
</I>&gt;<i> where rdf:Seq is a blank node whose identifier is derived from
</I>&gt;<i> concatenating the item and attribute UUIDs.
</I>
I'm very much an RDF novice, but the idea of creating all those special 
numbered properties seems scary.  It seems like those special ordinal 
properties aren't &quot;real&quot; properties (e.g. the user should never see them 
included in a list of properties).

What about having a single property, &quot;ordinal value&quot;, and using 
reification to assign a value for that property to a specific 
statement/entry?  Or, alternatively, instead of using reification to get 
a URI for statement, using the quad-store notion of a &quot;context&quot; or 
&quot;named graph&quot; to attach ordinal metadata to a statement?

Or, in order to start connecting the OpenRecord view code to RDF-based 
datastores, perhaps we need to abandon the whole OpenRecord ordinal 
idea, and adopt a more RDF-esque solution to the ordering problem?

:<i>o) Brian
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000298.html">[openrecord-dev] Re: Rhizome and OpenRecord
</A></li>
	<LI>Next message: <A HREF="000300.html">[openrecord-dev] Dojo Developer Day -- Sat May 13, 2006 -- Mountain View CA
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#299">[ date ]</a>
              <a href="thread.html#299">[ thread ]</a>
              <a href="subject.html#299">[ subject ]</a>
              <a href="author.html#299">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/openrecord-dev">More information about the openrecord-dev
mailing list</a><br>
</body></html>
